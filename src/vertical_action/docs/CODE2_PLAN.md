# 코드2 구현 계획: 전체 시나리오 제어

## 1. 목표 요약

- **실행 형태**: 런치파일로 실행
- **역할**: 진입 라인 번호 입력 → Nav2로 해당 위치 이동 → `/action`·`/action_check` 시나리오 제어 → `goal_return_finish` 후 다시 라인 입력 대기 (반복)

---

## 2. 시나리오 흐름 (순서도)

```
[시작]
   │
   ▼
┌──────────────────────────────┐
│ 진입할 라인 번호 입력 (1,2,3…) │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ data/line_positions.yaml에서  │
│ 해당 번호(line_N) 좌표 로드   │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ Nav2에 목표 전달 → 이동 시작   │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ Nav2 이동 완료 대기           │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ /action 에 "entering_start"  │
│ 발행                          │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ 0.5초 동안 /action_check 에   │
│ "entering_check" 수신 확인    │
│ → 없으면 "entering_start" 재전송 │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ /action_check 에서            │
│ "goal_finish" 수신 시 터미널 출력 │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ /action_check 에서            │
│ "goal_return_finish" 수신 대기 │
│ (로그만 출력)                  │
└──────────────────────────────┘
   │
   ▼
┌──────────────────────────────┐
│ "goal_return_finish" 수신     │
│ → 다시 "진입할 라인 입력"으로  │
└──────────────────────────────┘
   │
   └──────────────────────────────► (맨 위로 루프)
```

---

## 3. 토픽·데이터 정리

| 구분 | 토픽/경로 | 타입 | 방향 | 용도 |
|------|-----------|------|------|------|
| 목표 위치 | `data/line_positions.yaml` | - | 읽기 | 라인별 PoseStamped 형식 좌표 |
| Nav2 목표 | (Nav2 설정에 따름) | PoseStamped 또는 Action | 코드2→Nav2 | 이동 목표 전달 |
| Nav2 결과 | (Nav2 설정에 따름) | Result / 토픽 | Nav2→코드2 | 이동 완료 감지 |
| 액션 명령 | `/action` | std_msgs/String | 코드2·코드3→외부 | entering_start 등 |
| 액션 피드백 | `/action_check` | std_msgs/String | 외부→코드2 | entering_check, goal_finish, goal_return_finish |

---

## 4. 구현 단계 (순차 진행)

### 단계 1: 공통·설정
- [x] **1-1** 패키지에 Nav2 관련 의존성 추가 (`nav2_msgs` 등, 사용할 API에 맞춤)
- [x] **1-2** YAML 로드 유틸: `data/line_positions.yaml` 경로(소스 패키지 기준) 및 `line_N` → PoseStamped 변환 함수 작성 (코드1과 동일 경로 규칙 사용)

### 단계 2: Nav2 연동
- [x] **2-1** Nav2 목표 전달 방식 결정: 토픽(`/goal_pose` 등) vs 액션(`NavigateToPose`)
- [x] **2-2** 선택한 방식으로 “라인 N 좌표 → Nav2 목표 전송” 구현
- [x] **2-3** “이동 완료” 감지 구현 (결과 토픽/액션 결과 구독)

### 단계 3: 시나리오 제어 노드
- [x] **3-1** 시나리오 전용 노드 1개 생성 (예: `scenario_controller_node`)
- [x] **3-2** 진입 라인 번호 입력 (stdin 또는 파라미터/서비스): 1, 2, 3… (0 미사용)
- [x] **3-3** 위 순서도대로 상태 흐름 구현:
  - 라인 입력 → YAML 로드 → Nav2 이동 → 완료 후 `entering_start` → `entering_check` 0.5초 확인/재전송 → `goal_finish` 로그 → `goal_return_finish` 대기 → 다시 라인 입력

### 단계 4: 토픽 발행·구독
- [x] **4-1** `/action` 발행 (String): `entering_start`
- [x] **4-2** `/action_check` 구독 (String): `entering_check`, `goal_finish`, `goal_return_finish` 처리 및 로그/상태 전이

### 단계 5: 런치 및 정리
- [x] **5-1** 코드2 전용 런치파일 작성 (시나리오 노드만 또는 Nav2와 함께 실행하는 옵션)
- [x] **5-2** README에 코드2 실행 방법·파라미터·토픽 정리

---

## 5. 파일 구성 (목표)

```
src/vertical_action/
├── launch/
│   └── scenario_control.launch.py   # 코드2 런치 (단계 5에서 추가)
├── vertical_action/
│   ├── scenario_controller_node.py # 코드2 메인 노드 (단계 3)
│   └── (필요 시) nav2_goal_client.py 또는 yaml_pose_loader.py
├── data/
│   └── line_positions.yaml         # 기존 유지, 코드1과 동일 경로
└── docs/
    └── CODE2_PLAN.md               # 본 문서
```

---

## 6. 확인·결정 필요 사항

- **Nav2 목표 전달**: 사용 중인 Nav2 설정의 goal 토픽/액션 이름 (예: `/goal_pose`, `NavigateToPose` 액션 이름)
- **이동 완료 판단**: Nav2에서 “도착”을 어떤 토픽/액션 결과로 알리는지
- **라인 입력 방식**: 런치 후 터미널 stdin vs 서비스/파라미터 (런치 시 stdin 미연결 가능성 있음 → 서비스 또는 토픽 입력 고려)

---

## 7. 진행 시 유의사항

- 코드1과 동일하게 **저장/읽기 경로는 소스 패키지의 `data/`** 사용.
- `entering_check` 0.5초 내 미수신 시 **entering_start 재전송** 횟수/최대 횟수 정할 것.
- 코드2는 **런치로 실행**하므로, 라인 번호 입력은 서비스 호출 또는 토픽 구독으로 받는 쪽이 안정적.

이 순서대로 단계 1부터 순차 진행하면 됨.
